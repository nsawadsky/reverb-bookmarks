package ca.ubc.cs.reverb.indexer;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jsoup.nodes.Comment;
import org.jsoup.nodes.Node;

public class WebPageClassifier {
    /**
     * Starts with lower-case and contains at least one upper-case 
     *   OR
     * Starts with upper-case and contains at least one lower-case, followed by at least one upper-case
     *   OR
     * Starts with two or more upper-case and contains at least one lower-case
     *   OR
     * Starts with letter, contains letters, decimal digits, and at least one underscore.
     */
    private final static String IDENTIFIER_PATTERN_STRING = 
        "(?x) \\b (?: [a-z] \\w*? [A-Z] \\w* | [A-Z] \\w*? [a-z] \\w*? [A-Z] \\w* | [A-Z]{2,} \\w*? [a-z] \\w* |" + 
                "[a-zA-Z] \\w*? _ [a-zA-Z0-9] \\w* )";
    
    /**
     * Starts with an identifier, followed by open-bracket, followed by
     * at most 40 non-close-bracket characters, followed by an identifier. 
     */
    private final static String METHOD_PATTERN_STRING = 
        "(?x)" + IDENTIFIER_PATTERN_STRING + "\\s* \\( [^\\)]{0,40}?" + IDENTIFIER_PATTERN_STRING;
    
    /**
     * Starts with a word that begins with a lower- or upper-case letter, followed by
     * empty brackets.
     */
    private final static String NO_ARGS_METHOD_PATTERN_STRING = 
            "(?x) \\b [a-zA-Z]\\w* \\s* \\( \\s* \\)";

    /**
     * Starts with a word that begins with a lower- or upper-case letter, followed
     * by a dot or "->", followed by another word starting with a lower- or upper-case letter,
     * followed by open-bracket, followed by up to 200 characters, followed by 
     * close-bracket.
     */
    private final static String METHOD_INVOCATION_PATTERN = 
        "(?x) \\b [a-zA-Z]\\w* \\s* (?: \\. | ->) \\s* [a-zA-Z]\\w* \\s* \\( .{0,200}? \\)";
    
    private final static Pattern METHOD_PATTERN = Pattern.compile(METHOD_PATTERN_STRING, Pattern.DOTALL);
    private final static Pattern NO_ARGS_METHOD_PATTERN = Pattern.compile(NO_ARGS_METHOD_PATTERN_STRING, Pattern.DOTALL);

    /**
     * Comment inserted in auto-generated Javadoc.
     */
    public final static String JAVADOC_COMMENT = "Generated by javadoc";

    private final static int CODE_RELATED_MATCH_THRESHOLD = 2;

    public static boolean checkIsCodeRelated(String docText) {
        Matcher matcher = METHOD_PATTERN.matcher(docText);
        List<String> matches = new ArrayList<String>();
        while (matches.size() < CODE_RELATED_MATCH_THRESHOLD && matcher.find()) {
            String match = docText.substring(matcher.start(), matcher.end());
            matches.add(match);
        }
        
        if (matches.size() < CODE_RELATED_MATCH_THRESHOLD) {
            matcher = NO_ARGS_METHOD_PATTERN.matcher(docText);
            while (matches.size() < CODE_RELATED_MATCH_THRESHOLD && matcher.find()) {
                String match = docText.substring(matcher.start(), matcher.end());
                matches.add(match);
            }
        }

        if (matches.size() >= CODE_RELATED_MATCH_THRESHOLD) {
            return true;
        } else {
            return false;
        }
    }
    
    public static boolean checkIsJavadoc(org.jsoup.nodes.Document doc) {
        for (Node node: doc.head().childNodes()) {
            if (node instanceof Comment) {
                Comment comment = (Comment)node;
                String data = comment.getData();
                if (data != null && data.contains(JAVADOC_COMMENT)) {
                    return true;
                }
            }
        }
        return false;
    }
    
}
